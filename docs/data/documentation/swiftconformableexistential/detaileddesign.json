{"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/swiftconformableexistential\/detaileddesign"]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"primaryContentSections":[{"content":[{"level":2,"type":"heading","anchor":"Equality","text":"Equality"},{"type":"paragraph","inlineContent":[{"text":"Equality is evaluated via ","type":"text"},{"type":"codeVoice","code":"_ConformableExistentialEquatableSupport"},{"type":"text","text":" and"},{"type":"text","text":" "},{"code":"_ConformableExistentialEquatableSequenceSupport","type":"codeVoice"},{"type":"text","text":" internal protocols. Clients are"},{"type":"text","text":" "},{"text":"not intended to work with them directly, but the module use them to evaluate the equality of equatable","type":"text"},{"type":"text","text":" "},{"type":"text","text":"wrappers that clients have spawned. It enables to compare “unrelated” types:"}]},{"code":["EquatableDrinkable(.smallBeer) == EquatableOptionalDrinkable(.smallBeer) \/\/ true","EquatableDrinkable(.smallBeer) == HashableCodableMutableOptionalDrinkable(.smallBeer) \/\/ true","EquatableSequenceOfDrinkable([.smallBeer, .glassOfWater]) == HashableOptionalSequenceOfDrinkable([.smallBeer, .glassOfWater]) \/\/ true"],"type":"codeListing","syntax":"swift"},{"type":"heading","anchor":"Equality-of-collections","text":"Equality of collections","level":3},{"inlineContent":[{"type":"text","text":"Two wrappers over a collection of existentials are evaluated as equal if they have the same sequence type"},{"text":" ","type":"text"},{"type":"text","text":"and if the sequences contain equal elements at respective index (have same order). Ideally, the wrapper would"},{"text":" ","type":"text"},{"type":"text","text":"be declared with an “OrderedSequence” generic constraint, but no such protocol exists. Since unordered"},{"text":" ","type":"text"},{"type":"text","text":"collections typically rely on "},{"code":"Hashable","type":"codeVoice"},{"type":"text","text":" to form indices (e.g., "},{"type":"codeVoice","code":"Set"},{"text":"), and existentials cannot conform","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to "},{"code":"Hashable","type":"codeVoice"},{"text":" (","type":"text"},{"code":"Set<any Drinkable>","type":"codeVoice"},{"type":"text","text":" is ill-formed), it is very unlikely that this would become a problem"},{"text":" ","type":"text"},{"type":"text","text":"for clients. However, in such an unlikely case, clients can still resolve this issue by implementing"},{"type":"text","text":" "},{"text":"their own == operator on the wrapper that wraps the unordered collection.","type":"text"}],"type":"paragraph"},{"text":"Rationales","level":2,"anchor":"Rationales","type":"heading"},{"text":"Composited conformances","level":3,"anchor":"Composited-conformances","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The main reason for the existence of "},{"type":"codeVoice","code":"HashableCodableExistential"},{"text":" (and other composite variants),","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"in addition to the standalone "},{"type":"codeVoice","code":"HashableExistential"},{"type":"text","text":" and "},{"code":"CodableExistential","type":"codeVoice"},{"text":", is the limitation in","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the composition of property wrappers ("},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0258-property-wrappers.md#composition-of-property-wrappers","type":"reference"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0258-property-wrappers.md#composition"},{"text":" ","type":"text"},{"type":"text","text":")."}]},{"syntax":"swift","type":"codeListing","code":["struct Container: Hashable, Codable {","","    \/\/ Is ill-formed `HashableDrinkable<CodableDrinkable<DrinkableTypeCoding>>` because","    \/\/ `CodableDrinkable` doesn't conform to `Hashable`. ","    @HashableDrinkable","    @CodableDrinkable<DrinkableTypeCoding>","    let drinkable: any Drinkable","}"]},{"inlineContent":[{"text":"This limitation leaves us with the only option - to satisfy both ","type":"text"},{"code":"Hashable","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"Codable","type":"codeVoice"},{"type":"text","text":" requirements"},{"text":" ","type":"text"},{"type":"text","text":"in a single wrapper."}],"type":"paragraph"},{"syntax":"swift","code":["struct Container: Hashable, Codable {","","    @HashableCodableDrinkable<DrinkableTypeCoding>","    var drinkable: any Drinkable","}"],"type":"codeListing"},{"text":"<TypeCoding> generic expression","anchor":"<TypeCoding>-generic-expression","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"A codable wrapper does not take a "},{"code":"TypeCoding","type":"codeVoice"},{"text":" parameter in its initializer; instead, it is expressed","type":"text"},{"text":" ","type":"text"},{"text":"as a generic parameter. This allows compilation without forcing clients to initialize with arbitrarily","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"chosen “dumb” values."}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ Wouldn't compile; perhaps once - https:\/\/forums.swift.org\/t\/allow-property-wrappers-with-multiple-arguments-to-defer-initialization-when-wrappedvalue-is-not-specified\/38319","@HashableCodableDrinkable(with: DrinkableTypeCoding())","var drinkable: any Drinkable","","\/\/ It would compile, but would force clients to initialize it with a fabricated value.","@HashableCodableDrinkable(with: DrinkableTypeCoding())","var drinkable: any Drinkable = .smallBeer","","\/\/ The chosen expression compiles and allows `drinkable` to be defined in intialization.","@HashableCodableDrinkable<DrinkableTypeCoding>","var drinkable: any Drinkable"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The static nature of "},{"type":"codeVoice","code":"TypeCoding"},{"text":" generic parameter has also another benefit -","type":"text"},{"type":"text","text":" "},{"text":"the statically-defined information protects clients from loading unexpected data,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"similar to the protection provided by NSSecureCoding ("},{"identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/codableconfiguration#overview","type":"reference","isActive":true},{"type":"text","text":")."}]},{"anchor":"Sequence-and-RangeReplaceableCollection-wrapper-type-name-components","level":3,"text":"`Sequence` and `RangeReplaceableCollection` wrapper type name components","type":"heading"},{"inlineContent":[{"text":"To also support collections of existentials, the macros provide wrappers for these collections.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"These wrappers are generic, allowing you to choose your specific collection type."}],"type":"paragraph"},{"syntax":"swift","code":["@HashableSequenceOfDrinkable","var drinkablesArray: [any Drinkable]","","@HashableSequenceOfDrinkable","var drinkablesDeque: Deque<any Drinkable>"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Decodable (and by implication, Codable) collection wrappers require the collection to be a "},{"code":"RangeReplaceableCollection","type":"codeVoice"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"This is because their implementation depends on the "},{"code":"RangeReplaceableCollection.init<S>(_ elements: S)","type":"codeVoice"},{"type":"text","text":" constructor"},{"type":"text","text":" "},{"text":"when instantiating the collection from decoded elements. All the other wrappers utilize the most abstract","type":"text"},{"text":" ","type":"text"},{"code":"Sequence","type":"codeVoice"},{"text":" protocol.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"To clearly communicate the “collection variant” wrappers, and to respect the distinction between "},{"code":"Sequence","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"and "},{"code":"RangeReplaceableCollection","type":"codeVoice"},{"text":" generic constraints, I opted for this precise and formal notation.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once clients become familiar with the nature of the collection wrappers, they can simplify the verbose spelling with"},{"text":" ","type":"text"},{"type":"text","text":"typealias sugars as described in "},{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/Essentials#Mitigating-cumbersomeness-and-verbosity-of-synthesized-wrappers","isActive":true,"type":"reference"},{"type":"text","text":"."}]},{"anchor":"Alternatives-considered","level":4,"text":"Alternatives considered","type":"heading"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Express it by postfixig the protocol name with “s”, e.g. "},{"type":"codeVoice","code":"HashableDrinkables"},{"type":"text","text":" instead of"},{"text":" ","type":"text"},{"code":"HashableSequenceOfDrinkable","type":"codeVoice"},{"text":". This would break the macro’s ","type":"text"},{"type":"codeVoice","code":"names: prefixed"},{"type":"text","text":" declaration."}],"type":"paragraph"}]}],"type":"unorderedList"}],"kind":"content"}],"metadata":{"title":"Detailed design","modules":[{"name":"SwiftConformableExistential"}],"roleHeading":"Article","role":"article"},"seeAlsoSections":[{"title":"Articles","identifiers":["doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/Essentials"],"generated":true}],"hierarchy":{"paths":[["doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential"]]},"kind":"article","sections":[],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DetailedDesign"},"references":{"https://github.com/apple/swift-evolution/blob/main/proposals/0258-property-wrappers.md#composition-of-property-wrappers":{"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0258-property-wrappers.md#composition-of-property-wrappers","titleInlineContent":[{"text":"1","type":"text"}],"url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0258-property-wrappers.md#composition-of-property-wrappers","title":"1","type":"link"},"https://developer.apple.com/documentation/foundation/codableconfiguration#overview":{"type":"link","url":"https:\/\/developer.apple.com\/documentation\/foundation\/codableconfiguration#overview","title":"1","titleInlineContent":[{"type":"text","text":"1"}],"identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/codableconfiguration#overview"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/Essentials":{"type":"topic","kind":"article","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/Essentials","url":"\/documentation\/swiftconformableexistential\/essentials","role":"article","title":"Essentials","abstract":[]},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential":{"type":"topic","kind":"symbol","role":"collection","url":"\/documentation\/swiftconformableexistential","title":"SwiftConformableExistential","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential","abstract":[{"type":"text","text":"A set of Swift Macros designed to facilitate the conformance of existential types to"},{"type":"text","text":" "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":", "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":", "},{"type":"codeVoice","code":"Decodable"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Encodable"},{"type":"text","text":", and "},{"code":"Codable","type":"codeVoice"},{"text":".","type":"text"}]},"https://github.com/apple/swift-evolution/blob/main/proposals/0258-property-wrappers.md#composition":{"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0258-property-wrappers.md#composition","titleInlineContent":[{"text":"2","type":"text"}],"url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0258-property-wrappers.md#composition","title":"2","type":"link"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/Essentials#Mitigating-cumbersomeness-and-verbosity-of-synthesized-wrappers":{"type":"topic","url":"\/documentation\/swiftconformableexistential\/essentials#Mitigating-cumbersomeness-and-verbosity-of-synthesized-wrappers","kind":"section","title":"Mitigating cumbersomeness and verbosity of synthesized wrappers","abstract":[],"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/Essentials#Mitigating-cumbersomeness-and-verbosity-of-synthesized-wrappers"}}}