{"hierarchy":{"paths":[["doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential"]]},"identifier":{"url":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DetailedDesign","interfaceLanguage":"swift"},"kind":"article","seeAlsoSections":[{"title":"Articles","identifiers":["doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/Essentials"],"generated":true}],"schemaVersion":{"major":0,"minor":3,"patch":0},"metadata":{"modules":[{"name":"SwiftConformableExistential"}],"roleHeading":"Article","title":"Detailed design","role":"article"},"sections":[],"primaryContentSections":[{"content":[{"type":"heading","level":2,"text":"Equality","anchor":"Equality"},{"type":"paragraph","inlineContent":[{"text":"Equality is evaluated via ","type":"text"},{"code":"_ConformableExistentialEquatableSupport","type":"codeVoice"},{"type":"text","text":" and"},{"text":" ","type":"text"},{"code":"_ConformableExistentialEquatableSequenceSupport","type":"codeVoice"},{"type":"text","text":" internal protocols. Clients are"},{"type":"text","text":" "},{"text":"not intended to work with them directly, but the module use them to evaluate the equality of equatable","type":"text"},{"type":"text","text":" "},{"type":"text","text":"wrappers that clients have spawned. It enables to compare “unrelated” types:"}]},{"code":["EquatableDrinkable(.smallBeer) == EquatableOptionalDrinkable(.smallBeer) \/\/ true","EquatableDrinkable(.smallBeer) == HashableCodableMutableOptionalDrinkable(.smallBeer) \/\/ true","EquatableSequenceOfDrinkable([.smallBeer, .glassOfWater]) == HashableOptionalSequenceOfDrinkable([.smallBeer, .glassOfWater]) \/\/ true"],"syntax":"swift","type":"codeListing"},{"type":"heading","anchor":"Equality-of-collections","text":"Equality of collections","level":3},{"inlineContent":[{"type":"text","text":"Two wrappers over a collection of existentials are evaluated as equal if they have the same sequence type"},{"text":" ","type":"text"},{"text":"and if the sequences contain equal elements at respective index (have same order). Ideally, the wrapper would","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"be declared with an “OrderedSequence” generic constraint, but no such protocol exists. Since unordered"},{"type":"text","text":" "},{"type":"text","text":"collections typically rely on "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" to form indices (e.g., "},{"type":"codeVoice","code":"Set"},{"text":"), and existentials cannot conform","type":"text"},{"type":"text","text":" "},{"text":"to ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" ("},{"type":"codeVoice","code":"Set<any Drinkable>"},{"text":" is ill-formed), it is very unlikely that this would become a problem","type":"text"},{"type":"text","text":" "},{"text":"for clients. However, in such an unlikely case, clients can still resolve this issue by implementing","type":"text"},{"text":" ","type":"text"},{"text":"their own == operator on the wrapper that wraps the unordered collection.","type":"text"}],"type":"paragraph"},{"level":2,"type":"heading","text":"Rationales","anchor":"Rationales"},{"anchor":"Composited-conformances","level":3,"text":"Composited conformances","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"The main reason for the existence of ","type":"text"},{"type":"codeVoice","code":"HashableCodableExistential"},{"type":"text","text":" (and other composite variants),"},{"type":"text","text":" "},{"type":"text","text":"in addition to the standalone "},{"type":"codeVoice","code":"HashableExistential"},{"type":"text","text":" and "},{"code":"CodableExistential","type":"codeVoice"},{"text":", is the limitation in","type":"text"},{"text":" ","type":"text"},{"text":"the composition of property wrappers (","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0258-property-wrappers.md#composition-of-property-wrappers","type":"reference","isActive":true},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0258-property-wrappers.md#composition"},{"type":"text","text":" "},{"text":").","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct Container: Hashable, Codable {","","    \/\/ Is ill-formed `HashableDrinkable<CodableDrinkable<DrinkableTypeCoding>>` because","    \/\/ `CodableDrinkable` doesn't conform to `Hashable`. ","    @HashableDrinkable","    @CodableDrinkable<DrinkableTypeCoding>","    let drinkable: any Drinkable","}"]},{"inlineContent":[{"text":"This limitation leaves us with the only option - to satisfy both ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"text":" and ","type":"text"},{"code":"Codable","type":"codeVoice"},{"type":"text","text":" requirements"},{"text":" ","type":"text"},{"text":"in a single wrapper.","type":"text"}],"type":"paragraph"},{"code":["struct Container: Hashable, Codable {","","    @HashableCodableDrinkable<DrinkableTypeCoding>","    var drinkable: any Drinkable","}"],"syntax":"swift","type":"codeListing"},{"text":"<TypeCoding> generic expression","type":"heading","anchor":"<TypeCoding>-generic-expression","level":3},{"type":"paragraph","inlineContent":[{"text":"A codable wrapper does not take a ","type":"text"},{"code":"TypeCoding","type":"codeVoice"},{"text":" parameter in its initializer; instead, it is expressed","type":"text"},{"type":"text","text":" "},{"text":"as a generic parameter. This allows compilation without forcing clients to initialize with arbitrarily","type":"text"},{"type":"text","text":" "},{"text":"chosen “dumb” values.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Wouldn't compile; perhaps once - https:\/\/forums.swift.org\/t\/allow-property-wrappers-with-multiple-arguments-to-defer-initialization-when-wrappedvalue-is-not-specified\/38319","@HashableCodableDrinkable(with: DrinkableTypeCoding())","var drinkable: any Drinkable","","\/\/ It would compile, but would force clients to initialize it with a fabricated value.","@HashableCodableDrinkable(with: DrinkableTypeCoding())","var drinkable: any Drinkable = .smallBeer","","\/\/ The chosen expression compiles and allows `drinkable` to be defined in intialization.","@HashableCodableDrinkable<DrinkableTypeCoding>","var drinkable: any Drinkable"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The static nature of "},{"code":"TypeCoding","type":"codeVoice"},{"text":" generic parameter has also another benefit -","type":"text"},{"type":"text","text":" "},{"text":"the statically-defined information protects clients from loading unexpected data,","type":"text"},{"type":"text","text":" "},{"text":"similar to the protection provided by NSSecureCoding (","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/codableconfiguration#overview"},{"text":").","type":"text"}]},{"anchor":"Sequence-and-RangeReplaceableCollection-wrapper-type-name-components","text":"`Sequence` and `RangeReplaceableCollection` wrapper type name components","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To also support collections of existentials, the macros provide wrappers for these collections."},{"text":" ","type":"text"},{"text":"These wrappers are generic, allowing you to choose your specific collection type.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["@HashableSequenceOfDrinkable","var drinkablesArray: [any Drinkable]","","@HashableSequenceOfDrinkable","var drinkablesDeque: Deque<any Drinkable>"]},{"inlineContent":[{"text":"Decodable (and by implication, Codable) collection wrappers require the collection to be a ","type":"text"},{"code":"RangeReplaceableCollection","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"This is because their implementation depends on the ","type":"text"},{"code":"RangeReplaceableCollection.init<S>(_ elements: S)","type":"codeVoice"},{"type":"text","text":" constructor"},{"type":"text","text":" "},{"text":"when instantiating the collection from decoded elements. All the other wrappers utilize the most abstract","type":"text"},{"type":"text","text":" "},{"code":"Sequence","type":"codeVoice"},{"text":" protocol.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"To clearly communicate the “collection variant” wrappers, and to respect the distinction between ","type":"text"},{"type":"codeVoice","code":"Sequence"},{"type":"text","text":" "},{"type":"text","text":"and "},{"code":"RangeReplaceableCollection","type":"codeVoice"},{"type":"text","text":" generic constraints, I opted for this precise and formal notation."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once clients become familiar with the nature of the collection wrappers, they can simplify the verbose spelling with"},{"type":"text","text":" "},{"type":"text","text":"typealias sugars as described in "},{"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/Essentials#Mitigating-cumbersomeness-and-verbosity-of-synthesized-wrappers","isActive":true},{"text":".","type":"text"}]},{"anchor":"Alternatives-considered","text":"Alternatives considered","type":"heading","level":4},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Express it by postfixig the protocol name with “s”, e.g. "},{"type":"codeVoice","code":"HashableDrinkables"},{"text":" instead of","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"HashableSequenceOfDrinkable"},{"type":"text","text":". This would break the macro’s "},{"type":"codeVoice","code":"names: prefixed"},{"type":"text","text":" declaration."}]}]}],"type":"unorderedList"}],"kind":"content"}],"variants":[{"paths":["\/documentation\/swiftconformableexistential\/detaileddesign"],"traits":[{"interfaceLanguage":"swift"}]}],"references":{"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/Essentials#Mitigating-cumbersomeness-and-verbosity-of-synthesized-wrappers":{"type":"topic","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/Essentials#Mitigating-cumbersomeness-and-verbosity-of-synthesized-wrappers","kind":"section","url":"\/documentation\/swiftconformableexistential\/essentials#Mitigating-cumbersomeness-and-verbosity-of-synthesized-wrappers","abstract":[],"title":"Mitigating cumbersomeness and verbosity of synthesized wrappers"},"https://github.com/apple/swift-evolution/blob/main/proposals/0258-property-wrappers.md#composition-of-property-wrappers":{"title":"1","type":"link","identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0258-property-wrappers.md#composition-of-property-wrappers","titleInlineContent":[{"text":"1","type":"text"}],"url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0258-property-wrappers.md#composition-of-property-wrappers"},"https://github.com/apple/swift-evolution/blob/main/proposals/0258-property-wrappers.md#composition":{"type":"link","identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0258-property-wrappers.md#composition","titleInlineContent":[{"type":"text","text":"2"}],"url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0258-property-wrappers.md#composition","title":"2"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/Essentials":{"title":"Essentials","url":"\/documentation\/swiftconformableexistential\/essentials","abstract":[],"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/Essentials","role":"article","kind":"article","type":"topic"},"https://developer.apple.com/documentation/foundation/codableconfiguration#overview":{"title":"1","type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/codableconfiguration#overview","titleInlineContent":[{"text":"1","type":"text"}],"url":"https:\/\/developer.apple.com\/documentation\/foundation\/codableconfiguration#overview"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential":{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential","type":"topic","role":"collection","abstract":[{"text":"A set of Swift Macros designed to facilitate the conformance of existential types to","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":", "},{"code":"Hashable","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Decodable"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Encodable"},{"type":"text","text":", and "},{"code":"Codable","type":"codeVoice"},{"text":".","type":"text"}],"kind":"symbol","title":"SwiftConformableExistential","url":"\/documentation\/swiftconformableexistential"}}}