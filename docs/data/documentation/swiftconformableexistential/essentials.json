{"kind":"article","sections":[],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/swiftconformableexistential\/essentials"]}],"hierarchy":{"paths":[["doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential"]]},"identifier":{"url":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/Essentials","interfaceLanguage":"swift"},"seeAlsoSections":[{"title":"Articles","identifiers":["doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DetailedDesign"],"generated":true}],"schemaVersion":{"major":0,"minor":3,"patch":0},"metadata":{"roleHeading":"Article","title":"Essentials","modules":[{"name":"SwiftConformableExistential"}],"role":"article"},"primaryContentSections":[{"kind":"content","content":[{"type":"heading","text":"Applying the macros","level":2,"anchor":"Applying-the-macros"},{"type":"paragraph","inlineContent":[{"text":"This package provides macros that synthesize property wrappers for the existential type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"of an annotated protocol. Unlike the existential type itself, these wrappers do conform to"},{"text":" ","type":"text"},{"text":"the protocols they represent. These can be ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Hashable","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Decodable"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Encodable"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"and "},{"type":"codeVoice","code":"Codable"},{"type":"text","text":", or any combination thereof. To specify the conformance of the synthesized wrappers,"},{"text":" ","type":"text"},{"type":"text","text":"choose the respective macro:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"isActive":true,"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableExistential(accessModifier:)"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableExistential(accessModifier:)","type":"reference","isActive":true}]}]},{"content":[{"type":"paragraph","inlineContent":[{"isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DecodableExistential(accessModifier:)","type":"reference"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EncodableExistential(accessModifier:)","isActive":true}]}]},{"content":[{"inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/CodableExistential(accessModifier:)"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableDecodableExistential(accessModifier:)","isActive":true}]}]},{"content":[{"inlineContent":[{"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableEncodableExistential(accessModifier:)","isActive":true}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableCodableExistential(accessModifier:)","isActive":true}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableDecodableExistential(accessModifier:)","isActive":true}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableEncodableExistential(accessModifier:)","isActive":true}]}]},{"content":[{"inlineContent":[{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableCodableExistential(accessModifier:)","isActive":true,"type":"reference"}],"type":"paragraph"}]}]},{"inlineContent":[{"type":"text","text":"Apply a macro by attaching it to a protocol."}],"type":"paragraph"},{"syntax":"swift","code":["@HashableCodableExistential","protocol Drinkable: Hashable, Codable {","    var milliliters: Double { get }","}"],"type":"codeListing"},{"style":"warning","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The annotated protocol must explicitly inherit from protocols in the annotation macro."},{"text":" ","type":"text"},{"text":"For example:","type":"text"}]},{"syntax":"swift","code":["@HashableCodableExistential","protocol Drinkable: Hashable, Codable {}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"It does not have to match the conformances exactly though:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Ok because `Hashable` implies `Equatable` ","\/\/ and `Codable` implies `Encodable`.","@EquatableEncodableExistential","protocol Drinkable: Hashable, Codable {}"]}],"name":"Warning"},{"name":"Note","style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"},{"overridingTitle":"Understand","overridingTitleInlineContent":[{"text":"Understand","type":"text"}],"isActive":true,"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DetailedDesign#Composited-conformances"},{"type":"text","text":" why multiple"},{"type":"text","text":" "},{"type":"text","text":"conformances form a single composite wrapper."}]}]},{"text":"Synthesized property wrappers","level":2,"type":"heading","anchor":"Synthesized-property-wrappers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Every applied macro synthesizes property wrappers for the existential type, conforming to the protocols"},{"text":" ","type":"text"},{"type":"text","text":"the macro specifies. They come in regular, mutable, optional, collection, and any combination thereof variants."},{"text":" ","type":"text"},{"type":"text","text":"Specifically, each applied macro generates the following 8 wrapper variants:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"regular","type":"text"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"mutable"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"optional","type":"text"}],"type":"emphasis"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"mutable optional","type":"text"}],"type":"emphasis"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"collection"}],"type":"emphasis"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"mutable collection"}],"type":"emphasis"}]}]},{"content":[{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"optional collection","type":"text"}]}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"mutable optional collection"}],"type":"emphasis"}]}]}],"type":"unorderedList"},{"inlineContent":[{"text":"The formula for synthesized wrapper name is ","type":"text"},{"type":"codeVoice","code":"{conformance}{variant}{protocol name}"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For instance, attaching "},{"type":"codeVoice","code":"@HashableExistential"},{"text":" to ","type":"text"},{"code":"Drinkable","type":"codeVoice"},{"type":"text","text":" synthesizes these 8"},{"text":" ","type":"text"},{"text":"property wrappers:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["HashableDrinkable","HashableMutableDrinkable","HashableOptionalDrinkable","HashableSequenceOfDrinkable<T> where T: Sequence<any Drinkable>","HashableMutableOptionalDrinkable","HashableMutableSequenceOfDrinkable<T> where T: Sequence<any Drinkable>","HashableOptionalSequenceOfDrinkable<T> where T: Sequence<any Drinkable>","HashableMutableOptionalSequenceOfDrinkable<T> where T: Sequence<any Drinkable>"]},{"type":"paragraph","inlineContent":[{"text":"Collection variant wrappers are generic, allowing you to choose your specific collection type.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["@HashableSequenceOfDrinkable","var drinkablesArray: [any Drinkable]","","@HashableSequenceOfDrinkable","var drinkablesDeque: Deque<any Drinkable>"]},{"inlineContent":[{"type":"text","text":"Decodable (and by implication, Codable) collection wrappers require the collection to be a "},{"type":"codeVoice","code":"RangeReplaceableCollection"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"This is because their implementation depends on the ","type":"text"},{"code":"RangeReplaceableCollection.init<S>(_ elements: S)","type":"codeVoice"},{"type":"text","text":" constructor"},{"text":" ","type":"text"},{"type":"text","text":"when instantiating the collection from decoded elements. All the other wrappers utilize the most abstract"},{"type":"text","text":" "},{"type":"codeVoice","code":"Sequence"},{"text":" protocol.","type":"text"}],"type":"paragraph"},{"level":2,"anchor":"Utilizing-synthesized-property-wrappers","text":"Utilizing synthesized property wrappers","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Every synthesized wrapper is ","type":"text"},{"type":"codeVoice","code":"@propertyWrapper"},{"type":"text","text":". This enables the annotation of properties of"},{"type":"text","text":" "},{"text":"the existential type. This example also illustrates the significance of all variants:","type":"text"}]},{"code":["\/\/ Mutable variants allows mutating,","\/\/ e.g. `container.mutableDrinkable = .doubleEspresso`","\/\/ in comparison to non-mutable `drinkable`.","\/\/","\/\/ `TypeCoding` generic parameter is described further below","\/\/ in \"Coding\" section.","struct Container: Hashable, Codable {","","    @HashableCodableDrinkable<DrinkableTypeCoding>","    var drinkable: any Drinkable","","    @HashableCodableMutableDrinkable<DrinkableTypeCoding>","    var mutableDrinkable: any Drinkable","","    @HashableCodableOptionalDrinkable<DrinkableTypeCoding>","    var optionalDrinkable: (any Drinkable)?","","    @HashableCodableMutableOptionalDrinkable<DrinkableTypeCoding>","    var mutableOptionalDrinkable: (any Drinkable)?","    ","    @HashableCodableRangeReplaceableCollectionOfDrinkable<[any Drinkable], DrinkableTypeCoding>","    var drinkables: [any Drinkable]","","    @HashableCodableMutableRangeReplaceableCollectionOfDrinkable<[any Drinkable], DrinkableTypeCoding>","    var mutableDrinkables: [any Drinkable]","","    @HashableCodableOptionalRangeReplaceableCollectionOfDrinkable<[any Drinkable], DrinkableTypeCoding>","    var optionalDrinkables: [any Drinkable]?","","    @HashableCodableMutableOptionalRangeReplaceableCollectionOfDrinkable<[any Drinkable], DrinkableTypeCoding>","    var mutableOptionalDrinkables: [any Drinkable]?","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This makes all the properties ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Codable"},{"text":", allowing the compiler to synthesize ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"text":" ","type":"text"},{"type":"text","text":"and "},{"type":"codeVoice","code":"Codable"},{"text":" implementations for ","type":"text"},{"type":"codeVoice","code":"Container"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"All the wrappers project ","type":"text"},{"code":"self","type":"codeVoice"},{"type":"text","text":". This enables the use of projection when passing generic arguments:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let uniques = Set(container.$drinkables)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Alternatively, the wrappers can also be used on-the-fly, particularly in situations where employing"},{"text":" ","type":"text"},{"type":"text","text":"property wrappers is not suitable:"}]},{"syntax":"swift","code":["struct Tap: View {","","    @State private var drinkable: any Drinkable = .smallBeer","    ","    var body: some View {","        ...           ","        .onChange(of: HashableCodableDrinkable<DrinkableTypeCoding>(drinkable)) { _, newValue in","            runAnimation(for: newValue.wrappedValue)","        }","    }","","    private func submit() {","        do {","            let data = try encoder.encode(HashableCodableDrinkable<DrinkableTypeCoding>(drinkable))","            try client.push(data)","        } catch { ... }","    }","}"],"type":"codeListing"},{"code":["\/\/ `drinkalbes` in the scope are of `[any Drinkable]`","let drinkablesSet = Set(drinkables.map({ HashableDrinkable($0) }))"],"type":"codeListing","syntax":"swift"},{"type":"heading","level":3,"text":"Mitigating cumbersomeness and verbosity of synthesized wrappers","anchor":"Mitigating-cumbersomeness-and-verbosity-of-synthesized-wrappers"},{"style":"tip","name":"Tip","content":[{"inlineContent":[{"text":"With 11 macros available, each generating 8 wrappers to address all supported variants,","type":"text"},{"type":"text","text":" "},{"text":"the task of clearly identifying the conformance and variant of all 88 wrappers leads to","type":"text"},{"text":" ","type":"text"},{"text":"arguably cumbersome naming. To maintain clarity while mitigating this complexity,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"once you’re acquainted with their characteristics, you can simplify their usage with"},{"text":" ","type":"text"},{"type":"codeVoice","code":"typealias"},{"type":"text","text":", achieving more concise spelling:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["typealias AnyDrinkables = HashableCodableRangeReplaceableCollectionOfDrinkable<[any Drinkable], DrinkableTypeCoding>","\/\/ Or if you want to stick with just the type coding but not the collection type:","typealias AnyDrinkables<T> = HashableCodableRangeReplaceableCollectionOfDrinkable<T, DrinkableTypeCoding> where T: RangeReplaceableCollection<any Drinkable>","","@AnyDrinkables ","var drinkables: [any Drinkable]","","try encoder.encode(AnyDrinkables([.smallBeer]))"]}],"type":"aside"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Applying multiple macros to a protocol is also allowed:"}]},{"syntax":"swift","code":["@EquatableExistential \/\/ use less verbose `EquatableDrinkable` in places with just `Equatable` generic constraint","@HashableCodableExistential ","protocol Drinkable: Hashable, Codable {}"],"type":"codeListing"},{"type":"heading","level":2,"text":"Coding","anchor":"Coding"},{"inlineContent":[{"type":"text","text":"While hashing and evaluating equality of existentials can be done based on the wrapped existential"},{"text":" ","type":"text"},{"text":"value itself, coding presents a fundamental challenge. Specifically, decoding from an external","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"representation becomes impossible without knowing the concrete type."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct DecodableDrinkable: Decodable {","","    let wrappedValue: any Drinkable","","    init(from decoder: Decoder) throws {","        wrappedValue = \/\/ What type are we supposed to decode? ","    }"]},{"inlineContent":[{"type":"text","text":"To decode an existential, resolving the concrete type from the external representation is required first."},{"type":"text","text":" "},{"text":"The synthesized codable wrappers accomplish this via their ","type":"text"},{"type":"codeVoice","code":"TypeDecoding"},{"text":" generic parameter.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Similarly, the "},{"type":"codeVoice","code":"TypeEncoding"},{"type":"text","text":" generic parameter is responsible for encoding the type information,"},{"type":"text","text":" "},{"type":"text","text":"ensuring the value can be correctly decoded."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The most straightforward way to implement ","type":"text"},{"code":"TypeCoding","type":"codeVoice"},{"type":"text","text":" is by adopting "},{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/ProtocolMetatypeRepresentable","isActive":true,"type":"reference"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This type is designed to facilitate conversion back and forth between a metatype and its custom codable representation."},{"text":" ","type":"text"},{"type":"text","text":"It also includes coding key information, enabling the decoding and encoding of type information."}]},{"type":"paragraph","inlineContent":[{"text":"An example of implementing ","type":"text"},{"isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/ProtocolMetatypeRepresentable","type":"reference"},{"type":"text","text":" for "},{"code":"Drinkable","type":"codeVoice"},{"text":":","type":"text"}]},{"syntax":"swift","code":["enum DrinkableTypeCoding: String, ProtocolMetatypeRepresentable {","","    case beer, espresso, water","","    init?(_ type: any Drinkable.Type) {","        switch type {","            case is Beer.Type: self = .beer","            case is Espresso.Type: self = .espresso","            case is Water.Type: self = .water","            default: return nil","        }","    }","","    static let codingKey = AdHocCodingKey(stringValue: \"__type\")","","    var type: any Drinkable.Type {","        switch self {","            case .beer: Beer.self","            case .espresso: Espresso.self","            case .water: Water.self","        }","    }","}"],"type":"codeListing"},{"code":["\/\/ Tip: Sugar your DrinkableTypeCoding codable wrappers","typealias AnyDrinkables = HashableCodableRangeReplaceableCollectionOfDrinkable<[any Drinkable], DrinkableTypeCoding>","","let data = try! encoder.encode(AnyDrinkables([Espresso(milliliters: 20.0), Water(milliliters: 250.0)]))","print(String(data: data, encoding: .utf8)!)"],"type":"codeListing","syntax":"swift"},{"code":["[","  {","    \"__type\" : \"espresso\",","    \"milliliters\" : 20","  },","  {","    \"__type\" : \"water\",","    \"milliliters\" : 250","  }","]"],"type":"codeListing","syntax":"json"},{"code":["let decoded = try! decoder.decode(AnyDrinkables.self, from: data)","print(decoded.wrappedValue) \/\/ [Espresso(milliliters: 20.0), Water(milliliters: 250.0)]"],"type":"codeListing","syntax":"swift"},{"style":"tip","type":"aside","content":[{"inlineContent":[{"text":"Make your ","type":"text"},{"type":"codeVoice","code":"DrinkableTypeCoding"},{"text":" statically exhaustive.","type":"text"}],"type":"paragraph"},{"code":["protocol Drinkable {","    ...","    \/\/ Enforce every adopter to provide its `DrinkableTypeCoding`.","    static var typeRepresentation: DrinkableTypeCoding { get }","    ...","}","enum DrinkableTypeCoding: String, ProtocolMetatypeRepresentable {","    ...","    \/\/ Now, every Drinkable metatype has its compile-time representation.","    init?(_ type: any Drinkable.Type) {","        self = type.typeRepresentation","    }","    ..."],"type":"codeListing","syntax":"swift"}],"name":"Tip"},{"level":3,"type":"heading","text":"More abstract type coding strategies","anchor":"More-abstract-type-coding-strategies"},{"inlineContent":[{"isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/ProtocolMetatypeRepresentable","type":"reference"},{"text":" is essentially a high-level API that conforms to ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaCoding"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"TypeCoding"},{"text":" is specifically constrained to ","type":"text"},{"isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaCoding","type":"reference"},{"type":"text","text":" alone. If you need a more hands-on approach"},{"type":"text","text":" "},{"text":"to discovering types, or in representing them, conform your ","type":"text"},{"code":"TypeCoding","type":"codeVoice"},{"text":" to just ","type":"text"},{"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaCoding","isActive":true},{"text":" ","type":"text"},{"text":"or ","type":"text"},{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaDecoding","type":"reference","isActive":true},{"text":" \/ ","type":"text"},{"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaEncoding","isActive":true},{"type":"text","text":" for one-way type coding, to implement your arbitrary conversion"},{"text":" ","type":"text"},{"type":"text","text":"between a protocol metatype and its external representation."}],"type":"paragraph"},{"type":"heading","anchor":"Encoding-nil-values","level":3,"text":"Encoding nil values"},{"inlineContent":[{"type":"text","text":"If your external representation format specification requires "},{"type":"codeVoice","code":"nil"},{"text":" values of optional","type":"text"},{"text":" ","type":"text"},{"code":"(any Drinkable)?","type":"codeVoice"},{"type":"text","text":", or "},{"type":"codeVoice","code":"[any Drinkable]?"},{"type":"text","text":" to encode explicitly as null values, you can configure"},{"text":" ","type":"text"},{"type":"text","text":"this behavior in your "},{"type":"codeVoice","code":"TypeEncoding"},{"type":"text","text":" via "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/OptionalExistentialEncodingConfig"},{"type":"text","text":"."}],"type":"paragraph"},{"code":["enum DrinkableTypeCoding: String, OptionalExistentialEncodingConfig, ProtocolMetatypeRepresentable {","    ...","    static let shouldEncodeNil = true","    ...","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"This configuration makes ","type":"text"},{"type":"codeVoice","code":"HashableCodableOptionalDrinkable<DrinkableTypeCoding>(nil)"},{"text":" to explicitly encode","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as "},{"type":"codeVoice","code":"null"},{"type":"text","text":", as opposed to omitting the "},{"code":"nil","type":"codeVoice"},{"text":" value during encoding.","type":"text"}]},{"level":2,"text":"More info","type":"heading","anchor":"More-info"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DetailedDesign","isActive":true,"type":"reference"}]}]}]}]}],"references":{"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/HashableCodableExistential(accessModifier:)":{"url":"\/documentation\/swiftconformableexistential\/hashablecodableexistential(accessmodifier:)","title":"HashableCodableExistential(accessModifier:)","fragments":[{"text":"macro","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"HashableCodableExistential"},{"text":"(","kind":"text"},{"text":"accessModifier","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"TypeAccessModifier","kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO"},{"kind":"text","text":"?)"}],"type":"topic","role":"symbol","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableCodableExistential(accessModifier:)","kind":"symbol","abstract":[{"type":"text","text":"Synthetizes "},{"code":"Hashable & Codable","type":"codeVoice"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"text":" ","type":"text"},{"text":"over existentials of the annotated protocol.","type":"text"}]},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/ProtocolMetatypeRepresentable":{"type":"topic","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ProtocolMetatypeRepresentable","kind":"identifier"}],"abstract":[{"type":"text","text":"A type that can be converted to and from an associated value where the value"},{"text":" ","type":"text"},{"text":"is meant to be a protocol metatype.","type":"text"}],"url":"\/documentation\/swiftconformableexistential\/protocolmetatyperepresentable","navigatorTitle":[{"text":"ProtocolMetatypeRepresentable","kind":"identifier"}],"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/ProtocolMetatypeRepresentable","title":"ProtocolMetatypeRepresentable","kind":"symbol","role":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/EquatableExistential(accessModifier:)":{"url":"\/documentation\/swiftconformableexistential\/equatableexistential(accessmodifier:)","type":"topic","title":"EquatableExistential(accessModifier:)","role":"symbol","abstract":[{"text":"Synthetizes ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"type":"text","text":" "},{"type":"text","text":"over existentials of the annotated protocol."}],"fragments":[{"text":"macro","kind":"keyword"},{"kind":"text","text":" "},{"text":"EquatableExistential","kind":"identifier"},{"text":"(","kind":"text"},{"kind":"externalParam","text":"accessModifier"},{"kind":"text","text":": "},{"preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","text":"TypeAccessModifier","kind":"typeIdentifier"},{"text":"?)","kind":"text"}],"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableExistential(accessModifier:)","kind":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/MetaDecoding":{"title":"MetaDecoding","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"MetaDecoding","kind":"identifier"}],"role":"symbol","abstract":[{"type":"text","text":"A type that decodes meta information."}],"navigatorTitle":[{"text":"MetaDecoding","kind":"identifier"}],"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaDecoding","type":"topic","kind":"symbol","url":"\/documentation\/swiftconformableexistential\/metadecoding"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/EncodableExistential(accessModifier:)":{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EncodableExistential(accessModifier:)","abstract":[{"type":"text","text":"Synthetizes "},{"code":"Encodable","type":"codeVoice"},{"text":" property wrapper variants (regular, mutable, optional, collection and their combinations)","type":"text"},{"type":"text","text":" "},{"type":"text","text":"over existentials of the annotated protocol."}],"url":"\/documentation\/swiftconformableexistential\/encodableexistential(accessmodifier:)","role":"symbol","type":"topic","kind":"symbol","fragments":[{"kind":"keyword","text":"macro"},{"text":" ","kind":"text"},{"text":"EncodableExistential","kind":"identifier"},{"text":"(","kind":"text"},{"text":"accessModifier","kind":"externalParam"},{"kind":"text","text":": "},{"text":"TypeAccessModifier","kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO"},{"kind":"text","text":"?)"}],"title":"EncodableExistential(accessModifier:)"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/MetaCoding":{"type":"topic","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"MetaCoding","kind":"identifier"}],"abstract":[],"url":"\/documentation\/swiftconformableexistential\/metacoding","navigatorTitle":[{"text":"MetaCoding","kind":"identifier"}],"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaCoding","title":"MetaCoding","kind":"symbol","role":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential":{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential","type":"topic","role":"collection","abstract":[{"text":"A set of Swift Macros designed to facilitate the conformance of existential types to","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":", "},{"code":"Hashable","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Decodable"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Encodable"},{"type":"text","text":", and "},{"code":"Codable","type":"codeVoice"},{"text":".","type":"text"}],"kind":"symbol","title":"SwiftConformableExistential","url":"\/documentation\/swiftconformableexistential"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/MetaEncoding":{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaEncoding","role":"symbol","title":"MetaEncoding","kind":"symbol","navigatorTitle":[{"text":"MetaEncoding","kind":"identifier"}],"type":"topic","url":"\/documentation\/swiftconformableexistential\/metaencoding","abstract":[{"type":"text","text":"A type that encodes meta information."}],"fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"kind":"identifier","text":"MetaEncoding"}]},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/DetailedDesign":{"role":"article","kind":"article","url":"\/documentation\/swiftconformableexistential\/detaileddesign","type":"topic","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DetailedDesign","abstract":[],"title":"Detailed design"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/OptionalExistentialEncodingConfig":{"url":"\/documentation\/swiftconformableexistential\/optionalexistentialencodingconfig","type":"topic","title":"OptionalExistentialEncodingConfig","role":"symbol","navigatorTitle":[{"text":"OptionalExistentialEncodingConfig","kind":"identifier"}],"abstract":[{"type":"text","text":"A way to tell encodable optional existential wrapper to encode nil."}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"OptionalExistentialEncodingConfig","kind":"identifier"}],"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/OptionalExistentialEncodingConfig","kind":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/DecodableExistential(accessModifier:)":{"kind":"symbol","abstract":[{"text":"Synthetizes ","type":"text"},{"code":"Decodable","type":"codeVoice"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"type":"text","text":" "},{"type":"text","text":"over existentials of the annotated protocol."}],"title":"DecodableExistential(accessModifier:)","role":"symbol","type":"topic","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DecodableExistential(accessModifier:)","url":"\/documentation\/swiftconformableexistential\/decodableexistential(accessmodifier:)","fragments":[{"text":"macro","kind":"keyword"},{"text":" ","kind":"text"},{"text":"DecodableExistential","kind":"identifier"},{"text":"(","kind":"text"},{"text":"accessModifier","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"TypeAccessModifier","kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO"},{"text":"?)","kind":"text"}]},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/HashableDecodableExistential(accessModifier:)":{"url":"\/documentation\/swiftconformableexistential\/hashabledecodableexistential(accessmodifier:)","title":"HashableDecodableExistential(accessModifier:)","fragments":[{"kind":"keyword","text":"macro"},{"text":" ","kind":"text"},{"text":"HashableDecodableExistential","kind":"identifier"},{"text":"(","kind":"text"},{"text":"accessModifier","kind":"externalParam"},{"kind":"text","text":": "},{"text":"TypeAccessModifier","kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO"},{"text":"?)","kind":"text"}],"type":"topic","role":"symbol","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableDecodableExistential(accessModifier:)","kind":"symbol","abstract":[{"text":"Synthetizes ","type":"text"},{"code":"Hashable & Decodable","type":"codeVoice"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"text":" ","type":"text"},{"type":"text","text":"over existentials of the annotated protocol."}]},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/DetailedDesign#Composited-conformances":{"title":"Composited conformances","kind":"section","abstract":[],"type":"topic","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DetailedDesign#Composited-conformances","url":"\/documentation\/swiftconformableexistential\/detaileddesign#Composited-conformances"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/EquatableEncodableExistential(accessModifier:)":{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableEncodableExistential(accessModifier:)","abstract":[{"type":"text","text":"Synthetizes "},{"code":"Equatable & Encodable","type":"codeVoice"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"text":" ","type":"text"},{"text":"over existentials of the annotated protocol.","type":"text"}],"url":"\/documentation\/swiftconformableexistential\/equatableencodableexistential(accessmodifier:)","role":"symbol","type":"topic","kind":"symbol","fragments":[{"text":"macro","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"EquatableEncodableExistential"},{"text":"(","kind":"text"},{"text":"accessModifier","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"TypeAccessModifier","kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO"},{"kind":"text","text":"?)"}],"title":"EquatableEncodableExistential(accessModifier:)"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/EquatableDecodableExistential(accessModifier:)":{"url":"\/documentation\/swiftconformableexistential\/equatabledecodableexistential(accessmodifier:)","title":"EquatableDecodableExistential(accessModifier:)","type":"topic","role":"symbol","abstract":[{"text":"Synthetizes ","type":"text"},{"code":"Equatable & Decodable","type":"codeVoice"},{"text":" property wrapper variants (regular, mutable, optional, collection and their combinations)","type":"text"},{"type":"text","text":" "},{"text":"over existentials of the annotated protocol.","type":"text"}],"fragments":[{"text":"macro","kind":"keyword"},{"kind":"text","text":" "},{"text":"EquatableDecodableExistential","kind":"identifier"},{"text":"(","kind":"text"},{"kind":"externalParam","text":"accessModifier"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","kind":"typeIdentifier","text":"TypeAccessModifier"},{"text":"?)","kind":"text"}],"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableDecodableExistential(accessModifier:)","kind":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/EquatableCodableExistential(accessModifier:)":{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableCodableExistential(accessModifier:)","abstract":[{"type":"text","text":"Synthetizes "},{"code":"Equatable & Codable","type":"codeVoice"},{"text":" property wrapper variants (regular, mutable, optional, collection and their combinations)","type":"text"},{"type":"text","text":" "},{"type":"text","text":"over existentials of the annotated protocol."}],"url":"\/documentation\/swiftconformableexistential\/equatablecodableexistential(accessmodifier:)","role":"symbol","type":"topic","kind":"symbol","fragments":[{"kind":"keyword","text":"macro"},{"text":" ","kind":"text"},{"text":"EquatableCodableExistential","kind":"identifier"},{"text":"(","kind":"text"},{"text":"accessModifier","kind":"externalParam"},{"kind":"text","text":": "},{"text":"TypeAccessModifier","kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO"},{"kind":"text","text":"?)"}],"title":"EquatableCodableExistential(accessModifier:)"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/HashableExistential(accessModifier:)":{"url":"\/documentation\/swiftconformableexistential\/hashableexistential(accessmodifier:)","type":"topic","title":"HashableExistential(accessModifier:)","role":"symbol","abstract":[{"text":"Synthetizes ","type":"text"},{"code":"Hashable","type":"codeVoice"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"type":"text","text":" "},{"type":"text","text":"over existentials of the annotated protocol."}],"fragments":[{"text":"macro","kind":"keyword"},{"kind":"text","text":" "},{"text":"HashableExistential","kind":"identifier"},{"text":"(","kind":"text"},{"kind":"externalParam","text":"accessModifier"},{"kind":"text","text":": "},{"preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","text":"TypeAccessModifier","kind":"typeIdentifier"},{"text":"?)","kind":"text"}],"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableExistential(accessModifier:)","kind":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/CodableExistential(accessModifier:)":{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/CodableExistential(accessModifier:)","abstract":[{"type":"text","text":"Synthetizes "},{"code":"Codable","type":"codeVoice"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"text":" ","type":"text"},{"text":"over existentials of the annotated protocol.","type":"text"}],"url":"\/documentation\/swiftconformableexistential\/codableexistential(accessmodifier:)","role":"symbol","type":"topic","kind":"symbol","fragments":[{"text":"macro","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"CodableExistential"},{"text":"(","kind":"text"},{"text":"accessModifier","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"TypeAccessModifier","kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO"},{"kind":"text","text":"?)"}],"title":"CodableExistential(accessModifier:)"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/HashableEncodableExistential(accessModifier:)":{"kind":"symbol","title":"HashableEncodableExistential(accessModifier:)","type":"topic","abstract":[{"text":"Synthetizes ","type":"text"},{"code":"Hashable & Encodable","type":"codeVoice"},{"text":" property wrapper variants (regular, mutable, optional, collection and their combinations)","type":"text"},{"type":"text","text":" "},{"text":"over existentials of the annotated protocol.","type":"text"}],"role":"symbol","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableEncodableExistential(accessModifier:)","fragments":[{"text":"macro","kind":"keyword"},{"kind":"text","text":" "},{"text":"HashableEncodableExistential","kind":"identifier"},{"text":"(","kind":"text"},{"kind":"externalParam","text":"accessModifier"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","kind":"typeIdentifier","text":"TypeAccessModifier"},{"text":"?)","kind":"text"}],"url":"\/documentation\/swiftconformableexistential\/hashableencodableexistential(accessmodifier:)"}}}