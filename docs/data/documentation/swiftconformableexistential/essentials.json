{"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/swiftconformableexistential\/essentials"]}],"seeAlsoSections":[{"identifiers":["doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DetailedDesign"],"title":"Articles","generated":true}],"hierarchy":{"paths":[["doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential"]]},"sections":[],"schemaVersion":{"major":0,"minor":3,"patch":0},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/Essentials"},"metadata":{"role":"article","modules":[{"name":"SwiftConformableExistential"}],"roleHeading":"Article","title":"Essentials"},"primaryContentSections":[{"kind":"content","content":[{"type":"heading","text":"Applying the macros","level":2,"anchor":"Applying-the-macros"},{"inlineContent":[{"type":"text","text":"This package provides macros that synthesize property wrappers for the existential type"},{"text":" ","type":"text"},{"type":"text","text":"of an annotated protocol. Unlike the existential type itself, these wrappers do conform to"},{"text":" ","type":"text"},{"type":"text","text":"the protocols they represent. These can be "},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":", "},{"code":"Hashable","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"Decodable"},{"type":"text","text":", "},{"code":"Encodable","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"and ","type":"text"},{"code":"Codable","type":"codeVoice"},{"type":"text","text":", or any combination thereof. To specify the conformance of the synthesized wrappers,"},{"text":" ","type":"text"},{"type":"text","text":"choose the respective macro:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableExistential(accessModifier:)","type":"reference"}]}]},{"content":[{"inlineContent":[{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableExistential(accessModifier:)","type":"reference","isActive":true}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DecodableExistential(accessModifier:)","isActive":true,"type":"reference"}]}]},{"content":[{"inlineContent":[{"isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EncodableExistential(accessModifier:)","type":"reference"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"isActive":true,"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/CodableExistential(accessModifier:)"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"isActive":true,"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableDecodableExistential(accessModifier:)"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableEncodableExistential(accessModifier:)","type":"reference","isActive":true}]}]},{"content":[{"inlineContent":[{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableCodableExistential(accessModifier:)","type":"reference","isActive":true}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableDecodableExistential(accessModifier:)"}]}]},{"content":[{"inlineContent":[{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableEncodableExistential(accessModifier:)","type":"reference","isActive":true}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableCodableExistential(accessModifier:)","isActive":true}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"Apply a macro by attaching it to a protocol."}],"type":"paragraph"},{"syntax":"swift","code":["@HashableCodableExistential","protocol Drinkable: Hashable, Codable {","    var milliliters: Double { get }","}"],"type":"codeListing"},{"name":"Warning","content":[{"inlineContent":[{"type":"text","text":"The annotated protocol must explicitly inherit from protocols in the annotation macro."},{"type":"text","text":" "},{"text":"For example:","type":"text"}],"type":"paragraph"},{"code":["@HashableCodableExistential","protocol Drinkable: Hashable, Codable {}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"It does not have to match the conformances exactly though:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Ok because `Hashable` implies `Equatable` ","\/\/ and `Codable` implies `Encodable`.","@EquatableEncodableExistential","protocol Drinkable: Hashable, Codable {}"]}],"style":"warning","type":"aside"},{"style":"note","type":"aside","name":"Note","content":[{"inlineContent":[{"text":"","type":"text"},{"overridingTitleInlineContent":[{"type":"text","text":"Understand"}],"overridingTitle":"Understand","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DetailedDesign#Composited-conformances","type":"reference","isActive":true},{"type":"text","text":" why multiple"},{"type":"text","text":" "},{"type":"text","text":"conformances form a single composite wrapper."}],"type":"paragraph"}]},{"text":"Synthesized property wrappers","anchor":"Synthesized-property-wrappers","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"Every applied macro synthesizes property wrappers for the existential type, conforming to the protocols"},{"text":" ","type":"text"},{"text":"the macro specifies. They come in regular, mutable, optional, collection, and any combination thereof variants.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Specifically, each applied macro generates the following 8 wrapper variants:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"regular","type":"text"}],"type":"emphasis"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"mutable","type":"text"}],"type":"emphasis"}]}]},{"content":[{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"optional"}]}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"mutable optional","type":"text"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"collection"}]}]}]},{"content":[{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"mutable collection","type":"text"}]}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"optional collection"}],"type":"emphasis"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"mutable optional collection"}]}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The formula for synthesized wrapper name is "},{"code":"{conformance}{variant}{protocol name}","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"For instance, attaching ","type":"text"},{"code":"@HashableExistential","type":"codeVoice"},{"type":"text","text":" to "},{"type":"codeVoice","code":"Drinkable"},{"text":" synthesizes these 8","type":"text"},{"type":"text","text":" "},{"text":"property wrappers:","type":"text"}]},{"syntax":"swift","code":["HashableDrinkable","HashableMutableDrinkable","HashableOptionalDrinkable","HashableSequenceOfDrinkable<T> where T: Sequence<any Drinkable>","HashableMutableOptionalDrinkable","HashableMutableSequenceOfDrinkable<T> where T: Sequence<any Drinkable>","HashableOptionalSequenceOfDrinkable<T> where T: Sequence<any Drinkable>","HashableMutableOptionalSequenceOfDrinkable<T> where T: Sequence<any Drinkable>"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Collection variant wrappers are generic, allowing you to choose your specific collection type."}],"type":"paragraph"},{"code":["@HashableSequenceOfDrinkable","var drinkablesArray: [any Drinkable]","","@HashableSequenceOfDrinkable","var drinkablesDeque: Deque<any Drinkable>"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Decodable (and by implication, Codable) collection wrappers require the collection to be a "},{"type":"codeVoice","code":"RangeReplaceableCollection"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This is because their implementation depends on the "},{"type":"codeVoice","code":"RangeReplaceableCollection.init<S>(_ elements: S)"},{"type":"text","text":" constructor"},{"text":" ","type":"text"},{"text":"when instantiating the collection from decoded elements. All the other wrappers utilize the most abstract","type":"text"},{"type":"text","text":" "},{"code":"Sequence","type":"codeVoice"},{"type":"text","text":" protocol."}]},{"level":2,"type":"heading","anchor":"Utilizing-synthesized-property-wrappers","text":"Utilizing synthesized property wrappers"},{"inlineContent":[{"text":"Every synthesized wrapper is ","type":"text"},{"code":"@propertyWrapper","type":"codeVoice"},{"type":"text","text":". This enables the annotation of properties of"},{"text":" ","type":"text"},{"text":"the existential type. This example also illustrates the significance of all variants:","type":"text"}],"type":"paragraph"},{"code":["\/\/ Mutable variants allows mutating,","\/\/ e.g. `container.mutableDrinkable = .doubleEspresso`","\/\/ in comparison to non-mutable `drinkable`.","\/\/","\/\/ `TypeCoding` generic parameter is described further below","\/\/ in \"Coding\" section.","struct Container: Hashable, Codable {","","    @HashableCodableDrinkable<DrinkableTypeCoding>","    var drinkable: any Drinkable","","    @HashableCodableMutableDrinkable<DrinkableTypeCoding>","    var mutableDrinkable: any Drinkable","","    @HashableCodableOptionalDrinkable<DrinkableTypeCoding>","    var optionalDrinkable: (any Drinkable)?","","    @HashableCodableMutableOptionalDrinkable<DrinkableTypeCoding>","    var mutableOptionalDrinkable: (any Drinkable)?","    ","    @HashableCodableRangeReplaceableCollectionOfDrinkable<[any Drinkable], DrinkableTypeCoding>","    var drinkables: [any Drinkable]","","    @HashableCodableMutableRangeReplaceableCollectionOfDrinkable<[any Drinkable], DrinkableTypeCoding>","    var mutableDrinkables: [any Drinkable]","","    @HashableCodableOptionalRangeReplaceableCollectionOfDrinkable<[any Drinkable], DrinkableTypeCoding>","    var optionalDrinkables: [any Drinkable]?","","    @HashableCodableMutableOptionalRangeReplaceableCollectionOfDrinkable<[any Drinkable], DrinkableTypeCoding>","    var mutableOptionalDrinkables: [any Drinkable]?","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"This makes all the properties "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Codable"},{"text":", allowing the compiler to synthesize ","type":"text"},{"code":"Hashable","type":"codeVoice"},{"text":" ","type":"text"},{"text":"and ","type":"text"},{"code":"Codable","type":"codeVoice"},{"type":"text","text":" implementations for "},{"code":"Container","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"All the wrappers project "},{"type":"codeVoice","code":"self"},{"text":". This enables the use of projection when passing generic arguments:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let uniques = Set(container.$drinkables)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Alternatively, the wrappers can also be used on-the-fly, particularly in situations where employing"},{"text":" ","type":"text"},{"type":"text","text":"property wrappers is not suitable:"}]},{"type":"codeListing","syntax":"swift","code":["struct Tap: View {","","    @State private var drinkable: any Drinkable = .smallBeer","    ","    var body: some View {","        ...           ","        .onChange(of: HashableCodableDrinkable<DrinkableTypeCoding>(drinkable)) { _, newValue in","            runAnimation(for: newValue.wrappedValue)","        }","    }","","    private func submit() {","        do {","            let data = try encoder.encode(HashableCodableDrinkable<DrinkableTypeCoding>(drinkable))","            try client.push(data)","        } catch { ... }","    }","}"]},{"code":["\/\/ `drinkalbes` in the scope are of `[any Drinkable]`","let drinkablesSet = Set(drinkables.map({ HashableDrinkable($0) }))"],"type":"codeListing","syntax":"swift"},{"level":3,"anchor":"Mitigating-cumbersomeness-and-verbosity-of-synthesized-wrappers","type":"heading","text":"Mitigating cumbersomeness and verbosity of synthesized wrappers"},{"style":"tip","name":"Tip","content":[{"inlineContent":[{"type":"text","text":"With 11 macros available, each generating 8 wrappers to address all supported variants,"},{"text":" ","type":"text"},{"type":"text","text":"the task of clearly identifying the conformance and variant of all 88 wrappers leads to"},{"text":" ","type":"text"},{"text":"arguably cumbersome naming. To maintain clarity while mitigating this complexity,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"once youâ€™re acquainted with their characteristics, you can simplify their usage with"},{"type":"text","text":" "},{"code":"typealias","type":"codeVoice"},{"type":"text","text":", achieving more concise spelling:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["typealias AnyDrinkables = HashableCodableRangeReplaceableCollectionOfDrinkable<[any Drinkable], DrinkableTypeCoding>","\/\/ Or if you want to stick with just the type coding but not the collection type:","typealias AnyDrinkables<T> = HashableCodableRangeReplaceableCollectionOfDrinkable<T, DrinkableTypeCoding> where T: RangeReplaceableCollection<any Drinkable>","","@AnyDrinkables ","var drinkables: [any Drinkable]","","try encoder.encode(AnyDrinkables([.smallBeer]))"]}],"type":"aside"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Applying multiple macros to a protocol is also allowed:"}]},{"code":["@EquatableExistential \/\/ use less verbose `EquatableDrinkable` in places with just `Equatable` generic constraint","@HashableCodableExistential ","protocol Drinkable: Hashable, Codable {}"],"type":"codeListing","syntax":"swift"},{"type":"heading","level":2,"anchor":"Coding","text":"Coding"},{"inlineContent":[{"type":"text","text":"While hashing and evaluating equality of existentials can be done based on the wrapped existential"},{"type":"text","text":" "},{"type":"text","text":"value itself, coding presents a fundamental challenge. Specifically, decoding from an external"},{"type":"text","text":" "},{"type":"text","text":"representation becomes impossible without knowing the concrete type."}],"type":"paragraph"},{"code":["struct DecodableDrinkable: Decodable {","","    let wrappedValue: any Drinkable","","    init(from decoder: Decoder) throws {","        wrappedValue = \/\/ What type are we supposed to decode? ","    }"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"To decode an existential, resolving the concrete type from the external representation is required first.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The synthesized codable wrappers accomplish this via their "},{"type":"codeVoice","code":"TypeDecoding"},{"type":"text","text":" generic parameter."},{"type":"text","text":" "},{"text":"Similarly, the ","type":"text"},{"code":"TypeEncoding","type":"codeVoice"},{"type":"text","text":" generic parameter is responsible for encoding the type information,"},{"type":"text","text":" "},{"text":"ensuring the value can be correctly decoded.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The most straightforward way to implement "},{"code":"TypeCoding","type":"codeVoice"},{"text":" is by adopting ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/ProtocolMetatypeRepresentable"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"This type is designed to facilitate conversion back and forth between a metatype and its custom codable representation.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"It also includes coding key information, enabling the decoding and encoding of type information."}]},{"inlineContent":[{"type":"text","text":"An example of implementing "},{"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/ProtocolMetatypeRepresentable","isActive":true},{"type":"text","text":" for "},{"code":"Drinkable","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["enum DrinkableTypeCoding: String, ProtocolMetatypeRepresentable {","","    case beer, espresso, water","","    init?(_ type: any Drinkable.Type) {","        switch type {","            case is Beer.Type: self = .beer","            case is Espresso.Type: self = .espresso","            case is Water.Type: self = .water","            default: return nil","        }","    }","","    static let codingKey = AdHocCodingKey(stringValue: \"__type\")","","    var type: any Drinkable.Type {","        switch self {","            case .beer: Beer.self","            case .espresso: Espresso.self","            case .water: Water.self","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"codeListing","syntax":"swift","code":["\/\/ Tip: Sugar your DrinkableTypeCoding codable wrappers","typealias AnyDrinkables = HashableCodableRangeReplaceableCollectionOfDrinkable<[any Drinkable], DrinkableTypeCoding>","","let data = try! encoder.encode(AnyDrinkables([Espresso(milliliters: 20.0), Water(milliliters: 250.0)]))","print(String(data: data, encoding: .utf8)!)"]},{"code":["[","  {","    \"__type\" : \"espresso\",","    \"milliliters\" : 20","  },","  {","    \"__type\" : \"water\",","    \"milliliters\" : 250","  }","]"],"syntax":"json","type":"codeListing"},{"code":["let decoded = try! decoder.decode(AnyDrinkables.self, from: data)","print(decoded.wrappedValue) \/\/ [Espresso(milliliters: 20.0), Water(milliliters: 250.0)]"],"syntax":"swift","type":"codeListing"},{"style":"tip","name":"Tip","content":[{"type":"paragraph","inlineContent":[{"text":"Make your ","type":"text"},{"code":"DrinkableTypeCoding","type":"codeVoice"},{"text":" statically exhaustive.","type":"text"}]},{"syntax":"swift","code":["protocol Drinkable {","    ...","    \/\/ Enforce every adopter to provide its `DrinkableTypeCoding`.","    static var typeRepresentation: DrinkableTypeCoding { get }","    ...","}","enum DrinkableTypeCoding: String, ProtocolMetatypeRepresentable {","    ...","    \/\/ Now, every Drinkable metatype has its compile-time representation.","    init?(_ type: any Drinkable.Type) {","        self = type.typeRepresentation","    }","    ..."],"type":"codeListing"}],"type":"aside"},{"type":"heading","text":"More abstract type coding strategies","level":3,"anchor":"More-abstract-type-coding-strategies"},{"inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/ProtocolMetatypeRepresentable"},{"type":"text","text":" is essentially a high-level API that conforms to "},{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaCoding","type":"reference","isActive":true},{"type":"text","text":"."},{"text":" ","type":"text"},{"code":"TypeCoding","type":"codeVoice"},{"text":" is specifically constrained to ","type":"text"},{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaCoding","isActive":true,"type":"reference"},{"type":"text","text":" alone. If you need a more hands-on approach"},{"text":" ","type":"text"},{"text":"to discovering types, or in representing them, conform your ","type":"text"},{"code":"TypeCoding","type":"codeVoice"},{"type":"text","text":" to just "},{"isActive":true,"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaCoding"},{"type":"text","text":" "},{"type":"text","text":"or "},{"isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaDecoding","type":"reference"},{"type":"text","text":" \/ "},{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaEncoding","type":"reference","isActive":true},{"text":" for one-way type coding, to implement your arbitrary conversion","type":"text"},{"type":"text","text":" "},{"text":"between a protocol metatype and its external representation.","type":"text"}],"type":"paragraph"},{"text":"Encoding nil values","anchor":"Encoding-nil-values","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"If your external representation format specification requires ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":" values of optional","type":"text"},{"type":"text","text":" "},{"code":"(any Drinkable)?","type":"codeVoice"},{"type":"text","text":", or "},{"code":"[any Drinkable]?","type":"codeVoice"},{"type":"text","text":" to encode explicitly as null values, you can configure"},{"text":" ","type":"text"},{"type":"text","text":"this behavior in your "},{"code":"TypeEncoding","type":"codeVoice"},{"text":" via ","type":"text"},{"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/OptionalExistentialEncodingConfig","isActive":true},{"text":".","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["enum DrinkableTypeCoding: String, OptionalExistentialEncodingConfig, ProtocolMetatypeRepresentable {","    ...","    static let shouldEncodeNil = true","    ...","}"]},{"type":"paragraph","inlineContent":[{"text":"This configuration makes ","type":"text"},{"code":"HashableCodableOptionalDrinkable<DrinkableTypeCoding>(nil)","type":"codeVoice"},{"type":"text","text":" to explicitly encode"},{"type":"text","text":" "},{"type":"text","text":"as "},{"type":"codeVoice","code":"null"},{"type":"text","text":", as opposed to omitting the "},{"code":"nil","type":"codeVoice"},{"text":" value during encoding.","type":"text"}]},{"level":2,"type":"heading","text":"More info","anchor":"More-info"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DetailedDesign"}]}]}],"type":"unorderedList"}]}],"kind":"article","references":{"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/HashableEncodableExistential(accessModifier:)":{"title":"HashableEncodableExistential(accessModifier:)","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableEncodableExistential(accessModifier:)","kind":"symbol","role":"symbol","fragments":[{"kind":"keyword","text":"macro"},{"kind":"text","text":" "},{"text":"HashableEncodableExistential","kind":"identifier"},{"text":"(","kind":"text"},{"kind":"externalParam","text":"accessModifier"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"TypeAccessModifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO"},{"kind":"text","text":"?)"}],"type":"topic","url":"\/documentation\/swiftconformableexistential\/hashableencodableexistential(accessmodifier:)","abstract":[{"text":"Synthetizes ","type":"text"},{"type":"codeVoice","code":"Hashable & Encodable"},{"text":" property wrapper variants (regular, mutable, optional, collection and their combinations)","type":"text"},{"type":"text","text":" "},{"type":"text","text":"over existentials of the annotated protocol."}]},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/EquatableDecodableExistential(accessModifier:)":{"title":"EquatableDecodableExistential(accessModifier:)","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableDecodableExistential(accessModifier:)","kind":"symbol","role":"symbol","fragments":[{"kind":"keyword","text":"macro"},{"kind":"text","text":" "},{"kind":"identifier","text":"EquatableDecodableExistential"},{"kind":"text","text":"("},{"text":"accessModifier","kind":"externalParam"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","text":"TypeAccessModifier"},{"kind":"text","text":"?)"}],"type":"topic","url":"\/documentation\/swiftconformableexistential\/equatabledecodableexistential(accessmodifier:)","abstract":[{"type":"text","text":"Synthetizes "},{"type":"codeVoice","code":"Equatable & Decodable"},{"text":" property wrapper variants (regular, mutable, optional, collection and their combinations)","type":"text"},{"type":"text","text":" "},{"text":"over existentials of the annotated protocol.","type":"text"}]},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/EncodableExistential(accessModifier:)":{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EncodableExistential(accessModifier:)","type":"topic","title":"EncodableExistential(accessModifier:)","abstract":[{"type":"text","text":"Synthetizes "},{"code":"Encodable","type":"codeVoice"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"type":"text","text":" "},{"text":"over existentials of the annotated protocol.","type":"text"}],"role":"symbol","url":"\/documentation\/swiftconformableexistential\/encodableexistential(accessmodifier:)","fragments":[{"kind":"keyword","text":"macro"},{"kind":"text","text":" "},{"kind":"identifier","text":"EncodableExistential"},{"kind":"text","text":"("},{"text":"accessModifier","kind":"externalParam"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"TypeAccessModifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO"},{"kind":"text","text":"?)"}],"kind":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/EquatableCodableExistential(accessModifier:)":{"role":"symbol","fragments":[{"text":"macro","kind":"keyword"},{"kind":"text","text":" "},{"text":"EquatableCodableExistential","kind":"identifier"},{"kind":"text","text":"("},{"kind":"externalParam","text":"accessModifier"},{"text":": ","kind":"text"},{"text":"TypeAccessModifier","kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO"},{"text":"?)","kind":"text"}],"kind":"symbol","url":"\/documentation\/swiftconformableexistential\/equatablecodableexistential(accessmodifier:)","type":"topic","title":"EquatableCodableExistential(accessModifier:)","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableCodableExistential(accessModifier:)","abstract":[{"type":"text","text":"Synthetizes "},{"code":"Equatable & Codable","type":"codeVoice"},{"text":" property wrapper variants (regular, mutable, optional, collection and their combinations)","type":"text"},{"text":" ","type":"text"},{"text":"over existentials of the annotated protocol.","type":"text"}]},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/DecodableExistential(accessModifier:)":{"url":"\/documentation\/swiftconformableexistential\/decodableexistential(accessmodifier:)","fragments":[{"text":"macro","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"DecodableExistential"},{"kind":"text","text":"("},{"kind":"externalParam","text":"accessModifier"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","text":"TypeAccessModifier"},{"text":"?)","kind":"text"}],"type":"topic","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DecodableExistential(accessModifier:)","title":"DecodableExistential(accessModifier:)","kind":"symbol","abstract":[{"type":"text","text":"Synthetizes "},{"code":"Decodable","type":"codeVoice"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"text":" ","type":"text"},{"text":"over existentials of the annotated protocol.","type":"text"}],"role":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/ProtocolMetatypeRepresentable":{"type":"topic","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"ProtocolMetatypeRepresentable","kind":"identifier"}],"kind":"symbol","role":"symbol","url":"\/documentation\/swiftconformableexistential\/protocolmetatyperepresentable","title":"ProtocolMetatypeRepresentable","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/ProtocolMetatypeRepresentable","navigatorTitle":[{"kind":"identifier","text":"ProtocolMetatypeRepresentable"}],"abstract":[{"text":"A type that can be converted to and from an associated value where the value","type":"text"},{"text":" ","type":"text"},{"text":"is meant to be a protocol metatype.","type":"text"}]},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/DetailedDesign#Composited-conformances":{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DetailedDesign#Composited-conformances","url":"\/documentation\/swiftconformableexistential\/detaileddesign#Composited-conformances","kind":"section","title":"Composited conformances","abstract":[],"type":"topic"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential":{"type":"topic","kind":"symbol","role":"collection","url":"\/documentation\/swiftconformableexistential","title":"SwiftConformableExistential","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential","abstract":[{"type":"text","text":"A set of Swift Macros designed to facilitate the conformance of existential types to"},{"type":"text","text":" "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":", "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":", "},{"type":"codeVoice","code":"Decodable"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Encodable"},{"type":"text","text":", and "},{"code":"Codable","type":"codeVoice"},{"text":".","type":"text"}]},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/HashableCodableExistential(accessModifier:)":{"title":"HashableCodableExistential(accessModifier:)","type":"topic","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableCodableExistential(accessModifier:)","abstract":[{"type":"text","text":"Synthetizes "},{"code":"Hashable & Codable","type":"codeVoice"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"type":"text","text":" "},{"type":"text","text":"over existentials of the annotated protocol."}],"role":"symbol","url":"\/documentation\/swiftconformableexistential\/hashablecodableexistential(accessmodifier:)","fragments":[{"kind":"keyword","text":"macro"},{"kind":"text","text":" "},{"kind":"identifier","text":"HashableCodableExistential"},{"kind":"text","text":"("},{"kind":"externalParam","text":"accessModifier"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","text":"TypeAccessModifier"},{"text":"?)","kind":"text"}],"kind":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/DetailedDesign":{"title":"Detailed design","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DetailedDesign","kind":"article","role":"article","type":"topic","url":"\/documentation\/swiftconformableexistential\/detaileddesign","abstract":[]},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/HashableExistential(accessModifier:)":{"title":"HashableExistential(accessModifier:)","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableExistential(accessModifier:)","kind":"symbol","role":"symbol","fragments":[{"kind":"keyword","text":"macro"},{"kind":"text","text":" "},{"kind":"identifier","text":"HashableExistential"},{"kind":"text","text":"("},{"kind":"externalParam","text":"accessModifier"},{"kind":"text","text":": "},{"text":"TypeAccessModifier","kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO"},{"text":"?)","kind":"text"}],"type":"topic","url":"\/documentation\/swiftconformableexistential\/hashableexistential(accessmodifier:)","abstract":[{"type":"text","text":"Synthetizes "},{"type":"codeVoice","code":"Hashable"},{"text":" property wrapper variants (regular, mutable, optional, collection and their combinations)","type":"text"},{"type":"text","text":" "},{"text":"over existentials of the annotated protocol.","type":"text"}]},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/HashableDecodableExistential(accessModifier:)":{"url":"\/documentation\/swiftconformableexistential\/hashabledecodableexistential(accessmodifier:)","type":"topic","title":"HashableDecodableExistential(accessModifier:)","fragments":[{"text":"macro","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"HashableDecodableExistential"},{"text":"(","kind":"text"},{"text":"accessModifier","kind":"externalParam"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","kind":"typeIdentifier","text":"TypeAccessModifier"},{"kind":"text","text":"?)"}],"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableDecodableExistential(accessModifier:)","abstract":[{"text":"Synthetizes ","type":"text"},{"type":"codeVoice","code":"Hashable & Decodable"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"text":" ","type":"text"},{"type":"text","text":"over existentials of the annotated protocol."}],"role":"symbol","kind":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/MetaEncoding":{"kind":"symbol","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaEncoding","abstract":[{"type":"text","text":"A type that encodes meta information."}],"title":"MetaEncoding","navigatorTitle":[{"text":"MetaEncoding","kind":"identifier"}],"type":"topic","role":"symbol","url":"\/documentation\/swiftconformableexistential\/metaencoding","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"MetaEncoding","kind":"identifier"}]},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/CodableExistential(accessModifier:)":{"fragments":[{"kind":"keyword","text":"macro"},{"kind":"text","text":" "},{"kind":"identifier","text":"CodableExistential"},{"kind":"text","text":"("},{"text":"accessModifier","kind":"externalParam"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","text":"TypeAccessModifier"},{"kind":"text","text":"?)"}],"url":"\/documentation\/swiftconformableexistential\/codableexistential(accessmodifier:)","type":"topic","kind":"symbol","role":"symbol","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/CodableExistential(accessModifier:)","abstract":[{"type":"text","text":"Synthetizes "},{"type":"codeVoice","code":"Codable"},{"text":" property wrapper variants (regular, mutable, optional, collection and their combinations)","type":"text"},{"type":"text","text":" "},{"text":"over existentials of the annotated protocol.","type":"text"}],"title":"CodableExistential(accessModifier:)"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/EquatableExistential(accessModifier:)":{"url":"\/documentation\/swiftconformableexistential\/equatableexistential(accessmodifier:)","kind":"symbol","fragments":[{"kind":"keyword","text":"macro"},{"kind":"text","text":" "},{"kind":"identifier","text":"EquatableExistential"},{"kind":"text","text":"("},{"kind":"externalParam","text":"accessModifier"},{"kind":"text","text":": "},{"text":"TypeAccessModifier","kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO"},{"text":"?)","kind":"text"}],"title":"EquatableExistential(accessModifier:)","type":"topic","role":"symbol","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableExistential(accessModifier:)","abstract":[{"type":"text","text":"Synthetizes "},{"type":"codeVoice","code":"Equatable"},{"text":" property wrapper variants (regular, mutable, optional, collection and their combinations)","type":"text"},{"type":"text","text":" "},{"text":"over existentials of the annotated protocol.","type":"text"}]},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/MetaCoding":{"fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"MetaCoding","kind":"identifier"}],"title":"MetaCoding","navigatorTitle":[{"kind":"identifier","text":"MetaCoding"}],"abstract":[],"kind":"symbol","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaCoding","url":"\/documentation\/swiftconformableexistential\/metacoding","role":"symbol","type":"topic"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/OptionalExistentialEncodingConfig":{"url":"\/documentation\/swiftconformableexistential\/optionalexistentialencodingconfig","abstract":[{"text":"A way to tell encodable optional existential wrapper to encode nil.","type":"text"}],"navigatorTitle":[{"text":"OptionalExistentialEncodingConfig","kind":"identifier"}],"kind":"symbol","type":"topic","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/OptionalExistentialEncodingConfig","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"OptionalExistentialEncodingConfig"}],"title":"OptionalExistentialEncodingConfig","role":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/MetaDecoding":{"type":"topic","navigatorTitle":[{"text":"MetaDecoding","kind":"identifier"}],"abstract":[{"type":"text","text":"A type that decodes meta information."}],"kind":"symbol","title":"MetaDecoding","url":"\/documentation\/swiftconformableexistential\/metadecoding","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaDecoding","role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"MetaDecoding","kind":"identifier"}]},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/EquatableEncodableExistential(accessModifier:)":{"fragments":[{"text":"macro","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"EquatableEncodableExistential"},{"kind":"text","text":"("},{"kind":"externalParam","text":"accessModifier"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","text":"TypeAccessModifier"},{"kind":"text","text":"?)"}],"url":"\/documentation\/swiftconformableexistential\/equatableencodableexistential(accessmodifier:)","type":"topic","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableEncodableExistential(accessModifier:)","abstract":[{"type":"text","text":"Synthetizes "},{"type":"codeVoice","code":"Equatable & Encodable"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"text":" ","type":"text"},{"type":"text","text":"over existentials of the annotated protocol."}],"title":"EquatableEncodableExistential(accessModifier:)","role":"symbol","kind":"symbol"}}}